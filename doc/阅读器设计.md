作为一名资深 Android 工程师，我将不仅从代码实现角度，更从架构和用户体验角度为你设计这个阅读器。

在 Compose 中实现一个高性能、沉浸式的 PDF 阅读器，核心难点在于手势冲突处理（缩放/翻页 vs UI显隐）以及大文件的渲染性能。

以下是我的设计方案：

## 1. Composable 组件结构树设计
我们将页面分为三层：渲染层 (Content Layer)、交互层 (Overlay Layer) 和 导航层 (Navigation Layer)。
ReaderScreen (Root)
├── SharedTransitionLayout (处理入场动画)
│   └── Box (全屏容器，处理点击事件以切换 UI 显隐)
│       │
│       ├── Layer 1: DocumentRenderEngine (文档渲染层)
│       │   ├── AndroidView (嵌入 PDFView 或自定义 SurfaceView)
│       │   │   └── 负责：双指缩放、惯性滚动、双页渲染逻辑
│       │   └── Canvas (批注绘制层，覆盖在 PDF 之上，仅在批注模式激活)
│       │
│       ├── Layer 2: ImmersiveOverlay (沉浸式 UI 层 - ZIndex: 1)
│       │   ├── AnimatedVisibility (TopBar 容器)
│       │   │   └── ReaderTopBar (返回、文件名、书签)
│       │   │
│       │   ├── AnimatedVisibility (BottomBar 容器)
│       │   │   └── ReaderBottomBar
│       │   │       ├── ThumbnailPreviewBubble (悬浮缩略图气泡 - 跟随滑块移动)
│       │   │       └── PageSlider (页码进度条)
│       │   │
│       │   └── AnimatedVisibility (SideTools 容器)
│       │       └── FloatingToolMenu (右下角/侧边悬浮工具栏：画笔、目录、设置)
│       │
│       └── Layer 3: Dialogs & Sheets (模态层)
│           └── ModalNavigationDrawer (目录大纲侧边栏)

## 2. 核心 Jetpack Compose 代码实现
这段代码展示了如何组织 Scaffold（或者直接用 Box 以获得更好的沉浸感）、处理沉浸式状态栏动画、以及那个“带预览图的进度条”的实现逻辑。

注意：为了代码简洁，省略了部分 import 和具体样式细节。
@OptIn(ExperimentalSharedTransitionApi::class)
@Composable
fun ReaderScreen(
    fileId: String,
    sharedTransitionScope: SharedTransitionScope,
    animatedContentScope: AnimatedContentScope,
    onBack: () -> Unit
) {
    // UI 显隐状态
    var isOverlayVisible by remember { mutableStateOf(true) }
    // 阅读器状态
    var currentPage by remember { mutableIntStateOf(0) }
    var totalPages by remember { mutableIntStateOf(100) }
    var isTwoPageMode by remember { mutableStateOf(false) } // 横屏双页模式
    
    // 控制系统栏（状态栏/导航栏）的显隐
    val systemUiController = rememberSystemUiController() // Accompanist 或使用 WindowInsetsControllerCompat
    LaunchedEffect(isOverlayVisible) {
        if (isOverlayVisible) {
            systemUiController.showSystemBars()
        } else {
            systemUiController.hideSystemBars()
        }
    }

    // 根容器
    Scaffold(
        modifier = Modifier.fillMaxSize(),
        containerColor = Color.Black, // 沉浸式背景底色
        contentWindowInsets = WindowInsets(0, 0, 0, 0) // 忽略系统边距，全屏渲染
    ) { innerPadding ->
        
        Box(modifier = Modifier.fillMaxSize()) {
            // ------------------------------------------------------------
            // Layer 1: 文档内容 (底层)
            // ------------------------------------------------------------
            DocumentViewer(
                modifier = Modifier
                    .fillMaxSize()
                    .clickable(
                        interactionSource = remember { MutableInteractionSource() },
                        indication = null // 移除点击水波纹
                    ) {
                        isOverlayVisible = !isOverlayVisible // 点击切换 UI
                    }
                    // 共享元素转场：配合 Navigation 使用
                    .with(sharedTransitionScope) {
                        Modifier.sharedElement(
                            state = rememberSharedContentState(key = "file_card_$fileId"),
                            animatedVisibilityScope = animatedContentScope
                        )
                    },
                currentPage = currentPage,
                isTwoPageMode = isTwoPageMode,
                onPageChanged = { currentPage = it }
            )

            // ------------------------------------------------------------
            // Layer 2: 沉浸式 UI (上层)
            // ------------------------------------------------------------
            
            // TopBar: 顶部工具栏
            AnimatedVisibility(
                visible = isOverlayVisible,
                enter = slideInVertically() + fadeIn(),
                exit = slideOutVertically() + fadeOut(),
                modifier = Modifier.align(Alignment.TopCenter)
            ) {
                ReaderTopBar(
                    title = "会议纪要.pdf",
                    onBack = onBack
                )
            }

            // BottomBar: 底部进度条 + 缩略图
            AnimatedVisibility(
                visible = isOverlayVisible,
                enter = slideInVertically { it } + fadeIn(),
                exit = slideOutVertically { it } + fadeOut(),
                modifier = Modifier.align(Alignment.BottomCenter)
            ) {
                ReaderBottomBar(
                    currentPage = currentPage,
                    totalPages = totalPages,
                    onSeek = { targetPage -> 
                        // 这里可以实现渲染引擎的 jumpTo
                        currentPage = targetPage
                    }
                )
            }

            // Floating Tools: 悬浮工具栏
            AnimatedVisibility(
                visible = isOverlayVisible,
                enter = scaleIn() + fadeIn(),
                exit = scaleOut() + fadeOut(),
                modifier = Modifier
                    .align(Alignment.CenterEnd)
                    .padding(end = 24.dp)
            ) {
                FloatingToolMenu(
                    onPenClick = { /* 进入批注模式 */ },
                    onTocClick = { /* 打开目录 Drawer */ },
                    onSettingsClick = { /* 切换单/双页 */ }
                )
            }
        }
    }
}

// ------------------------------------------------------------
// 核心组件：带缩略图预览的 Slider
// ------------------------------------------------------------
@Composable
fun ReaderBottomBar(
    currentPage: Int,
    totalPages: Int,
    onSeek: (Int) -> Unit
) {
    var sliderPosition by remember { mutableFloatStateOf(currentPage.toFloat()) }
    var isDragging by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .background(Brush.verticalGradient(listOf(Color.Transparent, Color.Black.copy(alpha = 0.8f))))
            .padding(horizontal = 24.dp, vertical = 24.dp)
            .navigationBarsPadding() // 避开小白条
    ) {
        // 缩略图气泡 (仅拖拽时显示)
        AnimatedVisibility(
            visible = isDragging,
            enter = fadeIn() + scaleIn(),
            exit = fadeOut() + scaleOut()
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 8.dp)
            ) {
                // 计算气泡的水平偏移量，使其跟随滑块
                // 注意：这里需要更精确的 Layout 布局计算，此处仅为示意逻辑
                ThumbnailBubble(
                    pageIndex = sliderPosition.toInt(),
                    modifier = Modifier.align(Alignment.Center) // 实际需根据 sliderPosition 计算 offset
                )
            }
        }

        // 进度条
        Slider(
            value = sliderPosition,
            onValueChange = { 
                isDragging = true
                sliderPosition = it 
            },
            onValueChangeFinished = {
                isDragging = false
                onSeek(sliderPosition.toInt())
            },
            valueRange = 0f..totalPages.toFloat(),
            colors = SliderDefaults.colors(
                thumbColor = Color.White,
                activeTrackColor = MaterialTheme.colorScheme.primary
            )
        )
        
        // 页码文字
        Text(
            text = "${sliderPosition.toInt() + 1} / $totalPages",
            color = Color.White,
            style = MaterialTheme.typography.labelMedium,
            modifier = Modifier.align(Alignment.CenterHorizontally)
        )
    }
}

@Composable
fun ThumbnailBubble(pageIndex: Int, modifier: Modifier = Modifier) {
    Surface(
        shape = RoundedCornerShape(8.dp),
        color = Color.White,
        shadowElevation = 8.dp,
        modifier = modifier.size(width = 80.dp, height = 120.dp)
    ) {
        // 这里根据 pageIndex 渲染 PDF 的具体一页为 Bitmap
        Image(
            painter = painterResource(id = R.drawable.placeholder_pdf_page),
            contentDescription = null,
            contentScale = ContentScale.Crop
        )
    }
}

## 3. PDF 渲染库推荐与集成策略
在 Compose 中使用 PDF，不要完全自己写渲染引擎，那是一个深坑（涉及缓存、分块加载、OOM 处理）。

### 方案 A：AndroidPdfViewer (成熟稳定，强烈推荐)
这是一个经典的 View 体系库，但通过 AndroidView 集成到 Compose 非常完美。

Github: barteksc/AndroidPdfViewer

优点:

内置了双指缩放、惯性滑动、页码跳转。

支持夜间模式（Night Mode），可以直接反色 PDF，符合你的需求。

性能极其稳定，处理几百兆的文件也没问题。
AndroidView(
    factory = { context ->
        PDFView(context, null).apply {
            // 初始化配置
            maxZoom = 3f
            isSwipeEnabled = true
        }
    },
    update = { pdfView ->
        pdfView.fromFile(file)
            .defaultPage(currentPage)
            .nightMode(isDarkMode) // 你的需求：暗色模式适配
            .onPageChange { page, _ -> onPageChanged(page) }
            .load()
    }
)
### 方案 B：Bouquet (Compose 原生库)
如果你有极强的“Compose 洁癖”，不想用 AndroidView，可以使用这个库。

Github: Grizel/Bouquet

优点: 完全基于 Compose 编写，API 更符合 Compose 直觉。

缺点: 相比方案 A，在大文件渲染性能和手势平滑度上稍逊一筹，且社区活跃度不如前者。

### 方案 C：PSPDFKit (商业级体验)
如果预算允许，或者项目对**批注（手写、签名、高亮）**要求极高，不要试图自己用 Canvas 实现。

特点: 提供全套 UI，包括批注工具栏、目录、搜索。你的工作量会减少 90%。

适配: 它们有官方的 Jetpack Compose Wrapper。

## 4. 针对你的“双页模式”需求的特别建议
在平板横屏时，显示双页能极大提升阅读效率（类似书本）。

如果使用 AndroidPdfViewer：它原生不支持双页并排。你需要稍微魔改一下，或者简单粗暴地放两个 PDFView 实例并排（但这会消耗双倍内存）。

更佳策略：如果是 PPT 转换的 PDF（通常是横向的），直接单页全屏即可。如果是 A4 文档 PDF，建议在横屏时检测 WindowSizeClass，如果宽度足够，将 PDFView 的显示模式设置为“连续滚动”而非“翻页”，这样用户可以在屏幕上同时看到上一页的尾部和下一页的头部，达到类似双页的连续阅读体验。

总结
入场动画：使用 Compose 1.7+ 的 SharedTransitionLayout。

阅读引擎：用 AndroidView 包裹 AndroidPdfViewer，既稳又快。

交互层：使用 Box 叠加，配合 AnimatedVisibility 做沉浸式开关。

缩略图：需要自己写逻辑，根据 PDF 库的接口 renderPageToBitmap(pageIndex) 动态生成小图显示在 Slider 上方。