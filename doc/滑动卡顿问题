根据你的描述（“滑动很长距离但页面只动了一小段”），这通常不是性能卡顿（丢帧），而是滚动物理（Physics）配置冲突导致的。

在 AndroidPdfViewer 库中，罪魁祸首通常是 .fitEachPage(true) 和 .pageSnap(false) 的组合使用方式。

原因分析
在你的代码中，有这样一段配置：

Kotlin

.pageSnap(false) // 禁用自动吸附（这是对的，为了连续滚动）
.autoSpacing(true)
.pageFling(true) // 启用惯性滚动
.fitEachPage(true) // <--- 问题出在这里！
fitEachPage(true) 的作用：它会强制每一页都完整地适应屏幕的边界。当你尝试滚动时，这个设置会试图“锁住”当前页面，确保它完整显示，因此它会产生巨大的阻力，阻止你顺滑地滑向下一页，甚至会产生一种“回弹”或者“滑不动”的感觉。

你需要的效果：你想要的是类似网页或 Word 文档那样的“连续流式滚动”，页面宽度适应屏幕，但高度可以自由滚动。

解决方案
请在 ReaderScreen.kt 的 PDFViewerContent 函数中，将 .fitEachPage(true) 改为 .fitEachPage(false)。

修改后的代码片段如下：

Kotlin

// ... 在 PDFViewerContent 函数内 ...

update = { pdfView ->
    val configKey = "${file.absolutePath}_${isNightMode}_${isHorizontalScroll}_${isAnnotationMode}"

    if (pdfView.tag != configKey) {
        pdfView.tag = configKey
        pdfView.fromFile(file)
            .defaultPage(currentPage)
            .enableSwipe(!isAnnotationMode)
            .swipeHorizontal(isHorizontalScroll)
            .pageSnap(false)      // 保持 false，实现连续滚动
            .autoSpacing(true)    // 保持 true，页面间有空隙
            .pageFling(true)      // 保持 true，开启惯性
            .fitEachPage(false)   // <--- 【修改这里】改为 false，解除单页强制锁定
            .nightMode(isNightMode)
            .enableAnnotationRendering(true)
            .spacing(10)
            // ... 其他回调 ...
            .load()
    }
}
为什么改为 false 不会影响显示？
AndroidPdfViewer 默认的缩放策略（当 fitEachPage 为 false 时）在竖向滚动模式下，通常就是 Fit Width（适应宽度）。这正是大多数手机阅读器想要的效果：

宽度撑满屏幕。

高度自由延伸。

手指一滑，利用 .pageFling(true) 产生惯性，可以飞快地滑过好几页。

额外的优化建议（针对流畅度）
虽然上面的修改能解决“滑不动”的问题，但为了让你的阅读器在安卓手机上如丝般顺滑，建议检查以下两点：

渲染质量设置： 可以添加 .enableAntialiasing(true) 来让文字边缘更清晰，但这会轻微增加渲染负载。如果你的测试机是低端机型且觉得卡顿（掉帧），可以设为 false。我的机型性能可以，继续使用true

避免 LaunchedEffect 与 onPageChange 的循环冲突： 你代码中处理 isProgrammaticScroll 的逻辑其实已经很不错了。但为了保险起见，确保只有在跳转目录或点击缩略图时才将 isProgrammaticScroll 设为 true，而在 onPageChange 回调中（即用户手指滑动时）一定要将其设为 false（你代码里已经这么做了，保持住）。

总结： 只要把 .fitEachPage(true) 改为 .fitEachPage(false)，你的滚动体验应该会立刻变得像原生浏览器一样顺滑。你可以现在修改并重新打包测试。