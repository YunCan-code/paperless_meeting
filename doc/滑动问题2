如果 .fitEachPage(false) 已经设置，但依然出现“滑动距离长但页面只动一点点（或像在泥潭里）”的情况，这通常是由 autoSpacing(true) 与连续滚动模式冲突，或者 ModalNavigationDrawer 的手势抢占导致的。

请尝试以下 3步关键修改，这应该能彻底解决“滑动不跟手”的问题：

1. 修改 ReaderScreen.kt 中的 PDF 配置
请在 PDFViewerContent 函数中，同时禁用 autoSpacing 并确保 pageSnap 为 false。autoSpacing 会试图动态调整页面间距以“凑整”屏幕，这在连续滚动 (fitEachPage(false)) 时会产生极大的阻尼感。

Kotlin

// 在 PDFViewerContent 的 update = { ... } 块中
pdfView.fromFile(file)
    .defaultPage(currentPage)
    .enableSwipe(!isAnnotationMode)
    .swipeHorizontal(isHorizontalScroll)
    .pageSnap(false)       // 【保持 false】禁用翻页吸附
    .autoSpacing(false)    // 【关键修改】改为 false！autoSpacing 会干扰连续滚动
    .pageFling(true)       // 【保持 true】开启惯性
    .fitEachPage(false)    // 【保持 false】禁用单页强制适应
    .nightMode(isNightMode)
    // ...
2. 禁用侧滑菜单的“边缘手势”
你的 PDF 阅读器外层包裹了 ModalNavigationDrawer。默认情况下，它会监听屏幕左侧的滑动事件。当你试图上下滑动 PDF（尤其是手指稍微有点斜的时候），Drawer 的手势检测可能会“吃掉”一部分触摸事件，导致 PDF 滑动不连贯。

请修改 ReaderScreen 开头的 ModalNavigationDrawer 配置：

Kotlin

ModalNavigationDrawer(
    drawerState = drawerState,
    // 【关键修改】只允许在菜单打开时使用手势关闭，禁止在阅读时通过侧滑打开菜单
    // 这样 PDFView 就能独占所有的触摸事件
    gesturesEnabled = drawerState.isOpen, 
    drawerContent = { ... }
) { ... }
(注：你已经有了底部的“目录”按钮来打开菜单，所以禁用侧滑打开不仅能解决冲突，还能防止误触。)

3. (可选) 检查硬件加速
在极少数情况下，如果是高分辨率 PDF，渲染延迟会被误认为是滑动卡顿。可以在 PDFView 初始化时强制开启硬件加速（通常默认开启，但显式声明更稳妥）：

Kotlin

AndroidView(
    factory = { context ->
        PDFView(context, null).apply {
            pdfViewRef = this
            // 确保背景色设置正确
            setBackgroundColor(if(isNightMode) android.graphics.Color.BLACK else android.graphics.Color.WHITE)
            // 某些机型上可能需要这个
            setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null) 
        }
    },
    // ...
)
汇总修改后的 PDFViewerContent 代码
你可以直接替换 ReaderScreen.kt 中的 PDFViewerContent 函数，确保万无一失：

Kotlin

@OptIn(ExperimentalComposeUiApi::class)
@Composable
fun PDFViewerContent(
    file: File,
    isNightMode: Boolean,
    isHorizontalScroll: Boolean,
    isAnnotationMode: Boolean,
    currentPage: Int,
    isProgrammaticScroll: Boolean,
    currentStrokeColor: Int,
    annotations: List<AnnotationLine>,
    onPageChange: (Int, Int) -> Unit,
    onTap: () -> Unit,
    onAnnotationAdded: (AnnotationLine) -> Unit,
    onLoadToc: (List<Pair<Int, Bookmark>>) -> Unit,
    modifier: Modifier
) {
    var pdfViewRef by remember { mutableStateOf<PDFView?>(null) }
    val currentPoints = remember { mutableStateListOf<PointFCompat>() }

    Box(modifier = modifier) {
        AndroidView(
            factory = { context ->
                PDFView(context, null).apply {
                    pdfViewRef = this
                    // 显式开启硬件加速
                    setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null)
                    setBackgroundColor(if(isNightMode) android.graphics.Color.BLACK else android.graphics.Color.WHITE)
                }
            },
            modifier = Modifier.fillMaxSize(),
            update = { pdfView ->
                val configKey = "${file.absolutePath}_${isNightMode}_${isHorizontalScroll}_${isAnnotationMode}"
                
                if (pdfView.tag != configKey) {
                    pdfView.tag = configKey
                    pdfView.fromFile(file)
                        .defaultPage(currentPage)
                        .enableSwipe(!isAnnotationMode)
                        .swipeHorizontal(isHorizontalScroll)
                        .pageSnap(false)       // 连续滚动必备
                        .autoSpacing(false)    // 【重要】禁用自动间距，防止阻尼感
                        .pageFling(true)       // 开启惯性
                        .fitEachPage(false)    // 【重要】禁用单页锁定，实现网页式滚动
                        .nightMode(isNightMode)
                        .enableAnnotationRendering(true)
                        .spacing(10)           // 固定间距
                        .onPageChange { page, count -> 
                             if (page != currentPage) {
                                 onPageChange(page, count) 
                             }
                        }
                        .onLoad { nbPages ->
                             onLoadToc(flattenBookmarks(pdfView.tableOfContents))
                             // 初始加载时不触发 onPageChange 导致的状态重置
                        }
                        .onDraw { canvas, pageWidth, pageHeight, pageIdx ->
                             // ... (保持原本的绘图逻辑不变) ...
                             // 为节省篇幅此处省略，请保留你原来的 onDraw 代码
                             annotations.forEach { line ->
                                 if (line.pageIndex == pageIdx) {
                                     val paint = Paint().apply {
                                         color = line.color
                                         strokeWidth = line.strokeWidth
                                         style = Paint.Style.STROKE
                                         isAntiAlias = true
                                         strokeCap = Paint.Cap.ROUND
                                         strokeJoin = Paint.Join.ROUND
                                     }
                                     val path = Path()
                                     if (line.points.isNotEmpty()) {
                                         val start = line.points[0]
                                         path.moveTo(start.x * pageWidth, start.y * pageHeight)
                                         for (i in 1 until line.points.size) {
                                             val p = line.points[i]
                                             path.lineTo(p.x * pageWidth, p.y * pageHeight)
                                         }
                                         canvas.drawPath(path, paint)
                                     }
                                 }
                             }
                             if (isAnnotationMode && currentPoints.isNotEmpty() && currentPage == pageIdx) {
                                  val paint = Paint().apply {
                                      color = currentStrokeColor
                                      strokeWidth = 5f
                                      style = Paint.Style.STROKE
                                      isAntiAlias = true
                                      strokeCap = Paint.Cap.ROUND
                                      strokeJoin = Paint.Join.ROUND
                                  }
                                  val path = Path()
                                  val start = currentPoints[0]
                                  path.moveTo(start.x * pageWidth, start.y * pageHeight)
                                  for (i in 1 until currentPoints.size) {
                                      val p = currentPoints[i]
                                      path.lineTo(p.x * pageWidth, p.y * pageHeight)
                                  }
                                  canvas.drawPath(path, paint)
                             }
                        }
                        .onTap { 
                            onTap()
                            true 
                        }
                        .load()
                }
            }
        )

        // Sync Jump Logic
        LaunchedEffect(currentPage, isProgrammaticScroll) {
             pdfViewRef?.let { v ->
                 if (isProgrammaticScroll && v.currentPage != currentPage) {
                     v.jumpTo(currentPage)
                 }
             }
        }

        // Overlay for Drawing Input (保持不变)
        if (isAnnotationMode) {
             // ... (保持你原来的 Drawing Box 代码) ...
             Box(
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInteropFilter { event ->
                        // ... 保持原来的手写逻辑 ...
                        val v = pdfViewRef ?: return@pointerInteropFilter false
                        val viewWidth = v.width.toFloat()
                        val viewHeight = v.height.toFloat()
                        val pageSize = v.getPageSize(currentPage)
                        
                        if (pageSize != null && pageSize.width > 0) {
                             val pageW = pageSize.width.toFloat()
                             val pageH = pageSize.height.toFloat()
                             
                             val viewRatio = viewWidth / viewHeight
                             val pageRatio = pageW / pageH
                             var renderedW = viewWidth
                             var renderedH = viewHeight
                             var offsetX = 0f
                             var offsetY = 0f

                             if (pageRatio > viewRatio) {
                                  renderedH = viewWidth / pageRatio
                                  offsetY = (viewHeight - renderedH) / 2f
                             } else {
                                  renderedW = viewHeight * pageRatio
                                  offsetX = (viewWidth - renderedW) / 2f
                             }

                             val localX = event.x - offsetX
                             val localY = event.y - offsetY
                             val xRatio = (localX / renderedW).coerceIn(0f, 1f)
                             val yRatio = (localY / renderedH).coerceIn(0f, 1f)

                             when (event.action) {
                                 MotionEvent.ACTION_DOWN -> {
                                     currentPoints.clear()
                                     currentPoints.add(PointFCompat(xRatio, yRatio))
                                     v.invalidate()
                                     true
                                 }
                                 MotionEvent.ACTION_MOVE -> {
                                     currentPoints.add(PointFCompat(xRatio, yRatio))
                                     v.invalidate()
                                     true
                                 }
                                 MotionEvent.ACTION_UP -> {
                                     currentPoints.add(PointFCompat(xRatio, yRatio))
                                     val newLine = AnnotationLine(
                                         pageIndex = currentPage,
                                         points = currentPoints.toList(),
                                         color = currentStrokeColor,
                                         strokeWidth = 5f
                                     )
                                     onAnnotationAdded(newLine)
                                     currentPoints.clear()
                                     v.invalidate()
                                     true
                                 }
                                 else -> true
                             }
                        } else false
                    }
             )
        }
    }
}