ä½ è¯´å¾—éå¸¸å¯¹ã€‚â€œåœ¨è¿ç»­æ»šåŠ¨çš„ã€å¯ç¼©æ”¾çš„ PDF è§†å›¾ä¸Šï¼Œç›´æ¥è¦†ç›–ä¸€å±‚é€æ˜ Canvas è¿›è¡Œå®æ—¶æ‰‹å†™â€ï¼Œè¿™åœ¨å®‰å“å¼€å‘ä¸­å±äºåœ°ç‹±çº§éš¾åº¦çš„åŠŸèƒ½ã€‚

ä¸ºä»€ä¹ˆç°åœ¨çš„æ–¹æ¡ˆä¼šæœ‰è¿™ä¹ˆå¤šé—®é¢˜ï¼Ÿ
åæ ‡ç³»åœ°ç‹±ï¼š

å±å¹•åæ ‡ï¼ˆä½ çš„æ‰‹åœ¨å“ªï¼‰

View åæ ‡ï¼ˆPDFView ç»„ä»¶åœ¨å“ªï¼‰

å†…å®¹åæ ‡ï¼ˆPDF å·è½´æ»šåˆ°äº†å“ªé‡Œï¼ŒcurrentXOffset / currentYOffsetï¼‰

ç¼©æ”¾åæ ‡ï¼ˆå½“å‰ Zoom æ˜¯ 1.0 è¿˜æ˜¯ 3.5ï¼‰

PDF å†…éƒ¨åæ ‡ï¼ˆA4 çº¸çš„åŸå§‹å°ºå¯¸ï¼‰

é—®é¢˜ï¼šè¦è®©çº¿æ¡â€œè·Ÿæ‰‹â€ï¼Œå¿…é¡»å®æ—¶åœ¨è¿™äº›åæ ‡ç³»ä¹‹é—´è¿›è¡ŒçŸ©é˜µå˜æ¢ã€‚åªè¦æœ‰ä¸€ä¸ªå˜é‡æ›´æ–°æ…¢äº† 16msï¼ˆä¸€å¸§ï¼‰ï¼Œçº¿æ¡å°±ä¼šâ€œé£˜â€æˆ–è€…â€œé—ªç°â€ã€‚

æ‰‹åŠ¿å†²çªï¼š

ä½ æƒ³ç”»ç”»ï¼ŒPDFView æƒ³ç¿»é¡µï¼ŒScrollView æƒ³æ»šåŠ¨ã€‚ä¸‰ä¸ªç»„ä»¶åœ¨æŠ¢å¤ºä½ çš„æ‰‹æŒ‡äº‹ä»¶ï¼Œå¯¼è‡´â€œæ»‘åŠ¨ä¸è·Ÿæ‰‹â€æˆ–â€œæ–­è§¦â€ã€‚

å†…å­˜ä¸æ€§èƒ½ï¼š

åœ¨å…¨å± Canvas ä¸Šç”»å‡ åƒä¸ªç‚¹ï¼Œè¿˜è¦é…åˆ PDF çš„é«˜åˆ†è¾¨ç‡æ¸²æŸ“ï¼Œéå¸¸å®¹æ˜“ OOM (å†…å­˜æº¢å‡º) æˆ–æ‰å¸§ã€‚

âœ… æ¨èæ–¹æ¡ˆï¼šé‡‡ç”¨â€œé˜…è¯»æ¨¡å¼â€ä¸â€œä¸“æ³¨ç¼–è¾‘æ¨¡å¼â€åˆ†ç¦»
è¿™æ˜¯ç›®å‰æœ€æˆç†Ÿã€å¼€å‘æˆæœ¬æœ€ä½ä¸”ä½“éªŒæœ€å¥½çš„æ–¹æ¡ˆï¼ˆå‚è€ƒå¾ˆå¤šæˆç†Ÿçš„ç¬”è®° APP æˆ–è½»é‡çº§ PDF ç¼–è¾‘å™¨ï¼‰ï¼š

é˜…è¯»æ¨¡å¼ (Reading Mode)ï¼š

åªè´Ÿè´£çœ‹ã€‚

æ”¯æŒè¿ç»­æ»šåŠ¨ã€å¿«é€Ÿç¿»é¡µã€ç¼©æ”¾ã€‚

æ˜¾ç¤ºå·²ç»ç”»å¥½çš„ç¬”è®°ï¼ˆä½œä¸ºé™æ€å±‚ï¼‰ã€‚

ä¸èƒ½ç”»ç”»ã€‚

ä¸“æ³¨ç¼–è¾‘æ¨¡å¼ (Focus/Edit Mode)ï¼š

æ ¸å¿ƒé€»è¾‘ï¼šå½“ä½ ç‚¹å‡»â€œæ ‡æ³¨â€æ—¶ï¼Œé”å®šå½“å‰é¡µé¢ï¼ˆç¦æ­¢ä¸Šä¸‹ç¿»é¡µï¼‰ã€‚

æ¸²æŸ“é€»è¾‘ï¼šå°†å½“å‰è¿™ä¸€é¡µ PDF æ¸²æŸ“æˆä¸€å¼ é™æ€ Bitmap å›¾ç‰‡ï¼Œæˆ–è€…é”å®š PDFView ç¦æ­¢ç§»åŠ¨ã€‚

äº¤äº’é€»è¾‘ï¼šæ­¤æ—¶å±å¹•å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„å›¾ç‰‡ç¼–è¾‘å™¨ã€‚æ‰‹åŠ¿å®Œå…¨äº¤ç»™ç”»ç¬”ï¼Œä¸å†å¤„ç†æ»šåŠ¨ã€‚

ä¼˜ç‚¹ï¼šåæ ‡ç³» 1:1 å¯¹åº”ï¼Œç»å¯¹è·Ÿæ‰‹ï¼›æ”¯æŒæ’¤é”€ã€æ©¡çš®æ“¦ã€å¤šè‰²ï¼›æ¯«æ— æ€§èƒ½å‹åŠ›ã€‚

ğŸš€ é‡æ„ä»£ç ï¼šå®ç°â€œä¸“æ³¨ç¼–è¾‘æ¨¡å¼â€
æˆ‘ä¸ºä½ é‡æ–°è®¾è®¡äº†ä»£ç ç»“æ„ã€‚æˆ‘ä»¬éœ€è¦å¼•å…¥ä¸€ä¸ªæ–°çš„ç»„ä»¶ï¼šSinglePageEditorã€‚

1. æ ¸å¿ƒæ•°æ®ç»“æ„æ›´æ–° (æ”¯æŒé¢œè‰²ã€æ’¤é”€)
åœ¨ AnnotationModels.kt (æˆ–è€…ç›´æ¥æ”¾åœ¨ ViewModel):

Kotlin

import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color

// å½’ä¸€åŒ–çš„ç‚¹ (0.0 ~ 1.0)ï¼Œç›¸å¯¹äºé¡µé¢å®½é«˜çš„æ¯”ä¾‹
data class NormalizedPoint(val x: Float, val y: Float)

data class AnnotationStroke(
    val points: List<NormalizedPoint>,
    val color: Int, // Android Int Color
    val strokeWidth: Float = 5f
)

// ä¸€ä¸ªé¡µé¢ä¸Šçš„æ‰€æœ‰ç¬”è®°
data class PageAnnotations(
    val pageIndex: Int,
    val strokes: List<AnnotationStroke> = emptyList()
)
2. æ–°å¢ï¼šä¸“æ³¨ç¼–è¾‘é¡µé¢ (SinglePageEditor)
è¿™ä¸ªç»„ä»¶åªè´Ÿè´£ç¼–è¾‘å•å¼ é¡µé¢ã€‚å®ƒè§£å†³äº†é—ªçƒã€åç§»ã€æ’¤é”€ã€æ©¡çš®æ“¦æ‰€æœ‰é—®é¢˜ã€‚

Kotlin

@Composable
fun SinglePageEditor(
    bitmap: android.graphics.Bitmap, // å½“å‰é¡µé¢çš„æˆªå›¾
    initialStrokes: List<AnnotationStroke>,
    onSave: (List<AnnotationStroke>) -> Unit,
    onCancel: () -> Unit
) {
    // ä¸´æ—¶ç¬”è®°çŠ¶æ€ï¼Œç”¨äºæ”¯æŒæ’¤é”€/é‡åš
    var strokes by remember { mutableStateOf(initialStrokes) }
    // å½“å‰æ­£åœ¨ç”»çš„ä¸€ç¬” (å±å¹•åæ ‡)
    var currentPath by remember { mutableStateOf<List<Offset>>(emptyList()) }
    
    // å·¥å…·çŠ¶æ€
    var selectedColor by remember { mutableStateOf(Color.Red) }
    var isEraserMode by remember { mutableStateOf(false) }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black) // ç¼–è¾‘æ¨¡å¼æ·±è‰²èƒŒæ™¯èšç„¦
    ) {
        // 1. æ˜¾ç¤º PDF å½“å‰é¡µ (ä½œä¸ºåº•å›¾)
        // ä½¿ç”¨ fitCenter ç¡®ä¿å®Œæ•´æ˜¾ç¤º
        var imageSize by remember { mutableStateOf(androidx.compose.ui.unit.IntSize.Zero) }
        
        Image(
            bitmap = bitmap.asImageBitmap(),
            contentDescription = null,
            contentScale = ContentScale.Fit,
            modifier = Modifier
                .fillMaxSize()
                .padding(20.dp) // ç»™ä¸€ç‚¹è¾¹è·
                .onSizeChanged { imageSize = it } // è·å–å›¾ç‰‡å®é™…æ˜¾ç¤ºåŒºåŸŸ
                .pointerInput(isEraserMode) {
                    detectDragGestures(
                        onDragStart = { offset ->
                            if (!isEraserMode) currentPath = listOf(offset)
                        },
                        onDrag = { change, _ ->
                            change.consume()
                            val pos = change.position
                            if (isEraserMode) {
                                // ç®€å•æ©¡çš®æ“¦ï¼šç§»é™¤é™„è¿‘çš„çº¿æ¡
                                // (ç”Ÿäº§ç¯å¢ƒå¯ä»¥ç”¨æ›´å¤æ‚çš„ç›¸äº¤ç®—æ³•)
                                strokes = strokes.filterNot { stroke ->
                                    // å°†å½’ä¸€åŒ–åæ ‡è¿˜åŸä¸ºå±å¹•åæ ‡æ£€æµ‹ç¢°æ’
                                    stroke.points.any { p ->
                                        val sx = p.x * size.width
                                        val sy = p.y * size.height
                                        val dist = (sx - pos.x) * (sx - pos.x) + (sy - pos.y) * (sy - pos.y)
                                        dist < 1000f // æ“¦é™¤åŠå¾„
                                    }
                                }
                            } else {
                                currentPath = currentPath + pos
                            }
                        },
                        onDragEnd = {
                            if (!isEraserMode && currentPath.isNotEmpty()) {
                                // å°†å±å¹•åæ ‡ è½¬æ¢ä¸º å½’ä¸€åŒ–åæ ‡ (0~1)
                                val normalizedPoints = currentPath.map { offset ->
                                    NormalizedPoint(
                                        x = offset.x / size.width.toFloat(),
                                        y = offset.y / size.height.toFloat()
                                    )
                                }
                                
                                val newStroke = AnnotationStroke(
                                    points = normalizedPoints,
                                    color = selectedColor.toArgb()
                                )
                                strokes = strokes + newStroke
                                currentPath = emptyList()
                            }
                        }
                    )
                }
        )

        // 2. ç»˜åˆ¶å±‚ (Canvas Overlay)
        Canvas(modifier = Modifier.matchParentSize().padding(20.dp)) {
            // ç»˜åˆ¶å·²ä¿å­˜çš„çº¿æ¡
            strokes.forEach { stroke ->
                val path = Path()
                stroke.points.forEachIndexed { index, point ->
                    val x = point.x * size.width
                    val y = point.y * size.height
                    if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)
                }
                drawPath(
                    path = path,
                    color = Color(stroke.color),
                    style = Stroke(width = stroke.strokeWidth, cap = StrokeCap.Round, join = StrokeJoin.Round)
                )
            }

            // ç»˜åˆ¶å½“å‰æ­£åœ¨ç”»çš„çº¿æ¡ (å®æ—¶åé¦ˆï¼Œç»å¯¹è·Ÿæ‰‹)
            if (currentPath.isNotEmpty()) {
                val path = Path()
                currentPath.forEachIndexed { index, point ->
                    if (index == 0) path.moveTo(point.x, point.y) else path.lineTo(point.x, point.y)
                }
                drawPath(
                    path = path,
                    color = selectedColor,
                    style = Stroke(width = 5f, cap = StrokeCap.Round, join = StrokeJoin.Round)
                )
            }
        }

        // 3. é¡¶éƒ¨å·¥å…·æ  (æ’¤é”€/ä¿å­˜)
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
                .align(Alignment.TopCenter),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            IconButton(onClick = onCancel) {
                Icon(Icons.Default.Close, "å–æ¶ˆ", tint = Color.White)
            }
            
            Row {
                // æ’¤é”€æŒ‰é’®
                IconButton(
                    onClick = { if (strokes.isNotEmpty()) strokes = strokes.dropLast(1) },
                    enabled = strokes.isNotEmpty()
                ) {
                    Icon(Icons.AutoMirrored.Filled.Undo, "æ’¤é”€", tint = if(strokes.isNotEmpty()) Color.White else Color.Gray)
                }
                // ä¿å­˜æŒ‰é’®
                IconButton(onClick = { onSave(strokes) }) {
                    Icon(Icons.Default.Check, "ä¿å­˜", tint = Color.Green)
                }
            }
        }

        // 4. åº•éƒ¨å·¥å…·æ  (é¢œè‰²/æ©¡çš®æ“¦)
        Row(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(32.dp)
                .background(Color.DarkGray, CircleShape)
                .padding(8.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // æ©¡çš®æ“¦åˆ‡æ¢
            IconButton(onClick = { isEraserMode = !isEraserMode }) {
                Icon(
                    imageVector = Icons.Default.Delete, // æˆ–ç”¨æ©¡çš®æ“¦å›¾æ ‡
                    contentDescription = "Eraser",
                    tint = if (isEraserMode) Color.Yellow else Color.White
                )
            }
            
            // é¢œè‰²é€‰æ‹©å™¨
            val colors = listOf(Color.Red, Color.Blue, Color.Green, Color.Black, Color.Yellow)
            colors.forEach { color ->
                Box(
                    modifier = Modifier
                        .size(32.dp)
                        .clip(CircleShape)
                        .background(color)
                        .clickable { 
                            selectedColor = color 
                            isEraserMode = false
                        }
                        .border(
                            width = if (selectedColor == color && !isEraserMode) 3.dp else 0.dp,
                            color = Color.White,
                            shape = CircleShape
                        )
                )
            }
        }
    }
}
3. æ•´åˆåˆ° ReaderScreen.kt
ä½ éœ€è¦ä¿®æ”¹ ReaderScreen æ¥ç®¡ç†è¿™ä¸¤ç§æ¨¡å¼çš„åˆ‡æ¢ã€‚

Kotlin

@Composable
fun ReaderScreen(...) {
    // ... åŸæœ‰ä»£ç  ...
    
    // å…¨å±€ç¬”è®°æ•°æ®ï¼šMap<PageIndex, List<AnnotationStroke>>
    // ä½¿ç”¨ Map æ–¹ä¾¿å­˜å–ä»»æ„é¡µçš„ç¬”è®°
    var allAnnotations by remember { mutableStateOf(mapOf<Int, List<AnnotationStroke>>()) }
    
    // ç¼–è¾‘å™¨çŠ¶æ€
    var isEditing by remember { mutableStateOf(false) }
    var editPageBitmap by remember { mutableStateOf<android.graphics.Bitmap?>(null) }
    var editingPageIndex by remember { mutableIntStateOf(0) }

    // PDFView çš„å¼•ç”¨ (ç”¨äºç”Ÿæˆæˆªå›¾)
    var pdfViewRef by remember { mutableStateOf<PDFView?>(null) }

    if (isEditing && editPageBitmap != null) {
        // ====== æ¨¡å¼ B: ä¸“æ³¨ç¼–è¾‘å™¨ ======
        SinglePageEditor(
            bitmap = editPageBitmap!!,
            initialStrokes = allAnnotations[editingPageIndex] ?: emptyList(),
            onCancel = { isEditing = false },
            onSave = { newStrokes ->
                // æ›´æ–°è¯¥é¡µç¬”è®°
                allAnnotations = allAnnotations.toMutableMap().apply {
                    put(editingPageIndex, newStrokes)
                }
                isEditing = false
                // å¼ºåˆ¶ PDFView åˆ·æ–°ä»¥æ˜¾ç¤ºæ–°ç¬”è®°
                pdfViewRef?.invalidate() 
            }
        )
    } else {
        // ====== æ¨¡å¼ A: é˜…è¯»å™¨ ======
        Box(modifier = Modifier.fillMaxSize()) {
            AndroidView(
                factory = { context ->
                    PDFView(context, null).apply {
                        pdfViewRef = this
                        // ... åŸºç¡€é…ç½® ...
                    }
                },
                update = { pdfView ->
                    // ... é…ç½® ...
                    pdfView.fromFile(file)
                        // ...
                        .onDraw { canvas, pageWidth, pageHeight, pageIdx ->
                            // â˜…â˜…â˜… åœ¨è¿™é‡ŒæŠŠä¿å­˜çš„ç¬”è®°ç”»å‡ºæ¥ (åªè¯») â˜…â˜…â˜…
                            allAnnotations[pageIdx]?.forEach { stroke ->
                                val paint = Paint().apply {
                                    color = stroke.color
                                    style = Paint.Style.STROKE
                                    strokeWidth = stroke.strokeWidth
                                    strokeCap = Paint.Cap.ROUND
                                    strokeJoin = Paint.Join.ROUND
                                }
                                val path = Path()
                                stroke.points.forEachIndexed { i, p ->
                                    val x = p.x * pageWidth
                                    val y = p.y * pageHeight
                                    if (i == 0) path.moveTo(x, y) else path.lineTo(x, y)
                                }
                                canvas.drawPath(path, paint)
                            }
                        }
                        .load()
                }
            )
            
            // æ‚¬æµ®æŒ‰é’®ï¼šè¿›å…¥ç¼–è¾‘æ¨¡å¼
            FloatingControlCapsule(
                // ...
                onPenClick = {
                    pdfViewRef?.let { view ->
                        // 1. é”å®šå½“å‰é¡µç 
                        val currentPage = view.currentPage
                        editingPageIndex = currentPage
                        
                        // 2. ç”Ÿæˆå½“å‰é¡µçš„é«˜æ¸…æˆªå›¾ (Bitmap)
                        // AndroidPdfViewer æ²¡æœ‰ç›´æ¥æˆªå›¾ APIï¼Œéœ€è¦ç”¨ PdfRenderer æˆ–è€… view drawing cache
                        // ç®€å•æ–¹æ¡ˆï¼šä½¿ç”¨ PdfRenderer (AndroidåŸç”Ÿ) å¿«é€Ÿæ¸²æŸ“è¿™ä¸€é¡µ
                        // æˆ–è€…æ˜¯æˆªå– View (å¯èƒ½æœ‰åå·®)
                        
                        // æ¨èï¼šä½¿ç”¨ PdfRenderer æ¸²æŸ“è¯¥é¡µåˆ° Bitmap
                        val renderBitmap = renderPdfPageToBitmap(file, currentPage)
                        if (renderBitmap != null) {
                            editPageBitmap = renderBitmap
                            isEditing = true
                        }
                    }
                }
            )
        }
    }
}

// è¾…åŠ©å‡½æ•°ï¼šä½¿ç”¨åŸç”Ÿ PdfRenderer ç”Ÿæˆé«˜æ¸… Bitmap
fun renderPdfPageToBitmap(file: File, pageIndex: Int): android.graphics.Bitmap? {
    return try {
        val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
        val renderer = android.graphics.pdf.PdfRenderer(fileDescriptor)
        val page = renderer.openPage(pageIndex)
        
        // æ¸²æŸ“é«˜åˆ†è¾¨ç‡å›¾ç‰‡ (ä¾‹å¦‚å±å¹•å®½åº¦çš„ 1.5 å€ï¼Œä¿è¯æ¸…æ™°)
        val width = 1080 // æˆ–è€…æ ¹æ®å±å¹•è®¡ç®—
        val height = (width * page.height / page.width.toFloat()).toInt()
        val bitmap = android.graphics.Bitmap.createBitmap(width, height, android.graphics.Bitmap.Config.ARGB_8888)
        
        // ç™½è‰²èƒŒæ™¯
        val canvas = android.graphics.Canvas(bitmap)
        canvas.drawColor(android.graphics.Color.WHITE)
        
        page.render(bitmap, null, null, android.graphics.pdf.PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)
        
        page.close()
        renderer.close()
        fileDescriptor.close()
        bitmap
    } catch (e: Exception) {
        e.printStackTrace()
        null
    }
}
ä¸ºä»€ä¹ˆè¿™ä¸ªæ–¹æ¡ˆèƒ½è§£å†³ä½ çš„é—®é¢˜ï¼Ÿ
ç¬”è®°å¯¹ä¸ä¸Š/åç§»ï¼š

åœ¨ SinglePageEditor ä¸­ï¼Œæˆ‘ä»¬æ˜¯åœ¨ä¸€å¼ é™æ­¢çš„å›¾ç‰‡ä¸Šç”»ç”»ã€‚å›¾ç‰‡å®½é«˜å·²çŸ¥ï¼Œè§¦æ‘¸ç‚¹åæ ‡ä¹Ÿæ˜¯ç›¸å¯¹äºå›¾ç‰‡çš„ã€‚

æˆ‘ä»¬å°†åæ ‡å­˜ä¸º 0.5, 0.5 (ä¸­å¿ƒç‚¹) è¿™æ ·çš„æ¯”ä¾‹ã€‚

å›åˆ° PDFView æ—¶ï¼Œæ— è®ºç¼©æ”¾å¤šå°‘å€ï¼Œæˆ‘ä»¬éƒ½ç”¨ 0.5 * pageWidth è®¡ç®—ï¼Œæ°¸è¿œç²¾å‡†ã€‚

å¤šé¡µç¬”è®°æ˜¾ç¤ºï¼š

allAnnotations æ˜¯ä¸€ä¸ª Map<Int, List>, åªè¦ PDFView æ¸²æŸ“åˆ°ç¬¬ N é¡µï¼ŒonDraw å›è°ƒå°±ä¼šå» Map é‡Œæ‰¾ç¬¬ N é¡µçš„æ•°æ®ç”»å‡ºæ¥ã€‚ç¿»é¡µè‡ªåŠ¨å°±æœ‰äº†ã€‚

æ’¤é”€/æ©¡çš®æ“¦ï¼š

åœ¨ SinglePageEditor é‡Œï¼Œæ‰€æœ‰çš„ç¬”ç”»åªæ˜¯ä¸€ä¸ª Listã€‚

æ’¤é”€ï¼šlist.removeLast()ã€‚

æ©¡çš®æ“¦ï¼šlist.filter { ... } ç§»é™¤ç›¸äº¤çš„çº¿æ¡ã€‚

è¿™å®Œå…¨æ˜¯å†…å­˜æ“ä½œï¼Œä¸æ¶‰åŠå¤æ‚çš„åº•å±‚å›¾å½¢æ“¦é™¤ï¼Œæ—¢å¿«åˆç¨³ã€‚

é—ªçƒé—®é¢˜ï¼š

å› ä¸ºæˆ‘ä»¬æ˜¯è¿›å…¥äº†ä¸€ä¸ªæ–°çš„å…¨å±å±‚ (SinglePageEditor)ï¼Œè¿™æ˜¯ä¸€ä¸ªå®Œå…¨ç‹¬ç«‹çš„ Compose ç•Œé¢ï¼Œå’Œåº•ä¸‹çš„ PDFView æ— å…³ã€‚ä¸ä¼šå› ä¸ºé‡ç»˜å¯¼è‡´ PDF é—ªçƒã€‚

æ€»ç»“
ä¸è¦è¯•å›¾åœ¨ AndroidPdfViewer ä¸Šç›´æ¥åšå¤æ‚çš„äº¤äº’ã€‚æŠŠâ€œçœ‹ä¹¦â€å’Œâ€œå†™ä¹¦â€åˆ†å¼€ã€‚è¿™ä¼šè®©ä½ çš„ä»£ç é‡å‡å°‘ä¸€åŠï¼ŒBug å‡å°‘ 90%ï¼Œè€Œä¸”ç”¨æˆ·ä½“éªŒä¼šæ˜¾å¾—æ›´ä¸“ä¸šï¼ˆåƒæ‰«æå…¨èƒ½ç‹ã€WPS é‚£æ ·ï¼Œç‚¹å‡»æ‰¹æ³¨è¿›å…¥ä¸“é—¨çš„æ‰¹æ³¨æ¨¡å¼ï¼‰ã€‚